#!/bin/bash

# constants
VERSION='@VERSION@'     # updated at install time
BIOSBOOT_PARTITION_SIZE_KB=1024
IMAGE_SIZE_MARGIN_KB=0  # fs size estimation is enough pessimistic
MKSQUASHFS_OPTS="-b 1M -comp xz"
FAT_OVERHEAD_PERCENT=10
FS_OVERHEAD_PERCENT=15
LVM_OVERHEAD_PERCENT=4
MAX_WORK_IMAGE_OVERHEAD_KB=$((1024*1024))
DEBUG=1
DD="dd status=none"
DBSTCK_DIR="/usr/share/debootstick"

# get functions now
source $DBSTCK_DIR/scripts/create-image/functions
# and have them available in chrooted scripts
export chrooted_functions="$(
    cat $DBSTCK_DIR/scripts/create-image/functions)"

# check options
root_password_request="NO_REQUEST"
while [ $# != 0 ] 
do
    case "$1" in
        -h|--help)
            usage_and_exit 0
        ;;
        -v|--version)
            echo "debootstick $VERSION"
            exit 0
        ;;
        --config-root-password-ask)
            root_password_request="ASK"
            shift
        ;;
        --config-root-password-none)
            root_password_request="NO_PASSWORD"
            shift
        ;;
        *)
            break
        ;;
    esac
done

# we need 2 args
if [ -z "$2" ]
then
    usage_and_exit 1
fi

# ensure we are root
if [ "$USER" != "root" ]
then
    sudo $0 $*
    exit
fi

# 1st arg is a directory
if [ ! -d "$1" ]
then
    usage_and_exit
fi

# 2nd one is a writable file path
if [ ! -w $(dirname "$2") ] 
then
    usage_and_exit
fi

# if we are here, command line is ok :)
if [ "$root_password_request" == "ASK" ]
then
    while true
    do
        read -s -p "Enter root password: " passwd1
        echo
        read -s -p "Enter root password again: " passwd2
        echo
        if [ "$passwd1" = "$passwd2" ]
        then
            echo 'OK'
            root_password_request="root:$passwd1"
            break
        else
            echo 'Sorry, passwords do not match, please retry.'
        fi
    done
fi

ORIG_TREE="$(cd "$1"; pwd)"
STICK_OS_ID=$(uuidgen)
LVM_VG="DBSTCK-$STICK_OS_ID"
DBSTCK_TMPDIR=$(mktemp -du --tmpdir tmp.dbstck.XXXXX.d)
final_image_path="$(abspath "$2")"
if [ "$DEBUG" = "1" ]
then
    CHROOTED_DEBUG="--debug"
fi

final_cleanup()
{
    return_code=$1
    if [ "$1" -gt 0 ]   # if error
    then
        rm -f $final_image_path
    fi
}

start_failsafe_mode --toplevel final_cleanup

make_compressed_fs()
{   
    # these operations (up to the squashfs compression below)
    # should be fast: we are just removing or moving files 
    # in the same filesystem

    fs_tree=$(cd $1; pwd)
    
    # we will work with two subdirectories, 
    # '.fs.orig' & 'compressed'
    cd $fs_tree
    contents=$(ls -A)
    mkdir .fs.orig .fs.compressed
    mv $contents .fs.orig/
    
    cd .fs.orig

    # clean up
    rm -rf proc/* sys/* dev/* tmp/* run/* /var/cache/*

    # some files should be available early at boot 
    # (thus not compressed in the squashfs image)
    while read f
    do
        mkdir -p $(dirname $fs_tree/.fs.compressed/$f)
        mv $f $fs_tree/.fs.compressed/$f
    done << EOF
boot
bin/busybox
opt/debootstick/live/init/first-init.sh
$(find lib -name squashfs.ko)
EOF

    # move the init
    mv sbin/init sbin/init.orig
    
    # create compressed image
    quiet_mksquashfs "draft image - compressing (squashfs)" \
            $PWD $fs_tree/.fs.compressed/fs.squashfs $MKSQUASHFS_OPTS

    # the following operations should also be fast.

    # finalize compressed tree
    cd $fs_tree/.fs.compressed
    mkdir -p sbin proc sys tmp/os tmp/os_rw tmp/os_ro dev
    cd sbin
    ln -s ../opt/debootstick/live/init/first-init.sh init
    cd ../bin
    ln -s busybox sh

    # keep only the compressed version in fs_tree
    cd $fs_tree/.fs.compressed
    mv $(ls -A) ..
    cd ..
    rm -rf .fs.orig .fs.compressed

    # leave the file system (allow unmounting it...)
    cd $DBSTCK_TMPDIR
}

compute_min_fs_size()
{
	fs_mount_point=$1
	
	data_size_kb=$(du -sk $fs_mount_point | awk '{print $1}')
	min_fs_size_kb=$((data_size_kb*100/(100-FS_OVERHEAD_PERCENT)))

	# return this size
	echo $min_fs_size_kb
}

failsafe mkdir -p $DBSTCK_TMPDIR
cd $DBSTCK_TMPDIR
mkdir -p efi/part efi/boot/grub

# step0: generate a UEFI bootloader binary
echo -n "I: generating a UEFI bootloader binary... "
cd efi
cat > boot/grub/grub.cfg << EOF
insmod part_gpt
insmod lvm
search --set rootfs --label ROOT
configfile (\$rootfs)/boot/grub/grub.cfg
EOF
grub-mkstandalone \
        --directory="/usr/lib/grub/x86_64-efi/" --format="x86_64-efi"   \
        --compress="gz" --output="BOOTX64.efi"            \
        "boot/grub/grub.cfg"
efi_image_size_bytes=$(stat -c "%s" BOOTX64.efi)
efi_partition_size_kb=$((efi_image_size_bytes/1024*100/(100-FAT_OVERHEAD_PERCENT)))
cd ..
echo done

# step1: compute a stick size large enough for our work 
# (i.e. not for the final minimized version)
echo -n "I: draft image - computing a size large enough... "
fs_size_estimation=$(du -sk $ORIG_TREE | awk '{print $1}')
draft_image_size=$(( efi_partition_size_kb + 
                    BIOSBOOT_PARTITION_SIZE_KB + 
                    fs_size_estimation +
                    MAX_WORK_IMAGE_OVERHEAD_KB))
echo done

# step2: create draft image structure
echo -n "I: draft image - partitioning and formatting... "
create_formatted_image \
        draft \
        $draft_image_size \
        $efi_partition_size_kb \
        ${LVM_VG}_DRAFT
echo done

# step3: copy original tree to work image and modify it
echo -n "I: draft image - copying filesystem tree... "
cd $draft_lvroot_mountpoint
cp -rp $ORIG_TREE/* .
echo done
mkdir -p opt/debootstick
cp -rp $DBSTCK_DIR/scripts/live opt/debootstick/live
cp -p $DBSTCK_DIR/scripts/create-image/chrooted-customization.sh .
chroot . ./chrooted-customization.sh $CHROOTED_DEBUG \
                $draft_device $root_password_request
rm ./chrooted-customization.sh
cat > dbstck.conf << EOF
LVM_VG=$LVM_VG
EOF
cd ..

# step4: compress the filesystem tree
make_compressed_fs $draft_lvroot_mountpoint

# step5: compute minimal size of final stick
echo -n "I: final image - computing minimal image size... "
cd $DBSTCK_TMPDIR
min_fs_size_kb=$(compute_min_fs_size $draft_lvroot_mountpoint)
part3_start_sector=$(sgdisk -p $draft_file | tail -n 1 | awk '{print $2}')
sector_size=$(sgdisk -p $draft_file | grep 'sector size' | awk '{print $(NF-1)}')
min_part3_size_kb=$((min_fs_size_kb * 100/(100-LVM_OVERHEAD_PERCENT)))
min_stick_size_kb=$((    part3_start_sector / 1024 * sector_size +
                                min_part3_size_kb +
                                IMAGE_SIZE_MARGIN_KB))
echo done

# step6: copy work version to the final image (with minimal size)

# prepare a final image with minimal size
echo -n "I: final image - partitioning and formatting... "
create_formatted_image \
        final \
        $min_stick_size_kb \
        $efi_partition_size_kb \
        ${LVM_VG} \
        $final_image_path
echo done
echo -n "I: final image - copying content from draft image... "
cp -rp $draft_lvroot_mountpoint/* $final_lvroot_mountpoint/
echo done
release_image draft     # not needed anymore

# step7: install BIOS bootloader

echo -n "I: final image - setting up the bootloader... "
cd $final_lvroot_mountpoint
# since the size of the filesystem mounted there is minimized,
# creating new files may cause problems.
# so we will use the directory /tmp that we mount in memory.
failsafe mount -t tmpfs none $final_lvroot_mountpoint/tmp
# /bin will be bind-mounted (see chrooted-grub-install.sh), 
# making /bin/busybox unaccessible.
# So we will use a copy in /tmp instead.
cp -p bin/busybox tmp
cp -p $DBSTCK_DIR/scripts/create-image/chrooted-grub-install.sh tmp
chroot . tmp/busybox sh tmp/chrooted-grub-install.sh $final_device
undo mount -t tmpfs none $final_lvroot_mountpoint/tmp
cd ..
echo done

# step8: setup the EFI boot partition
echo -n "I: final image - setting up the EFI boot partition... "
mkdir -p $final_efipart_mountpoint/EFI/BOOT
mv $DBSTCK_TMPDIR/efi/BOOTX64.efi $final_efipart_mountpoint/EFI/BOOT/
echo done

# step9: clean up
echo -n "I: cleaning up... "
release_image final
undo mkdir -p $DBSTCK_TMPDIR
echo done

chmod a+rw $final_image_path
echo "I: $final_image_path ready."

